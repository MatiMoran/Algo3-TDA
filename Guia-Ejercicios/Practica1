Practica 1: tecnicas algoritmicas

Bactracking

1) SumaSubconjuntosBT       
    Las soluciones (candidatas) son los vectores a = (a1 , . . . , an ) de valores binarios; el subconjunto
    de C representado por a contiene a ci si y sólo si ai = 1.
    a es una solución válida cuando la suma del subconjunto es igual a k.

    (a) C = {6, 12, 6} y k = 12
    soluciones candidatas: a1 = (0, 0, 0)   a2 = (1, 0, 0)  a3 = (1, 1, 0)  a4 = (1, 0, 1)
                        a5 = (1, 1, 1)   a6 = (0, 1, 1)  a7 = (0, 0, 1)  a8 = (0, 1, 0)     

    (b) C = {6, 12, 6} y k = 12
    soluciones validas: a1 = (0, 1, 0)  a2 = (1, 0, 1)

    (c) C = {6, 12, 6} y k = 12
    soluciones parciales: p1 = ()   -> p2 = (0) -> p3 = (0, 0) -> p4 = (0, 0, 0)
                                                            -> p5 = (0, 0, 1)
                                                -> p6 = (0, 1) -> p7 = (0, 1, 0)
                                                            -> p8 = (0, 1, 1)
                                    -> p9 = (1) -> p10 = (1, 0) -> p11 = (1, 0, 0)
                                                                -> p12 = (1, 0, 1)
                                                -> p13 = (1, 1) -> p14 = (1, 1, 0)
                                                                -> p15 = (1, 1, 1)

    (d) El arbol de backtracking es similar a las soluciones parciales, se empieza con la solucion vacia y se van agregando o no
    agregando elemntos al subconjunto, los nodos intermedios son soluciones parciales, y la hojas son soluciones candidatas.
    Las soluciones candidatas que sumen 12 seran las soluciones validas.

    (e) Me convence :)

    (f) Me convence también :)

    (g) árbol de llamadas recursivas: C = {6, 12, 6} y k = 12. Llamada: ss(C, |C|, k)

    llamada recursiva: ss(C, i - 1, j) v ss(C, i - 1, j - C[i])

    ss(C, 3, 12) -> ss(C, 2, 12)                                                  
                -> ss(C, 1, 12)                   v                       ss(C, 1, 0)
                    -> ss(C, 0, 12) v ss(C, 0, 6)                             -> ss(C, 0, 0) v ss(C, 0, -6)
                        false       v     false                                   true (0,1,0) v false
                v
                -> ss(C, 2, 6)
                -> ss(C, 1, 6)                   v                       ss(C, 1, -6)
                    -> ss(C, 0, 6) v ss(C, 0, 0)                             -> ss(C, 0, -6) v ss(C, 0, -12)
                        false       v true (1,0,1)                                false      v  false



    (h) Me convence x3 :)

    (i) Factibilidad: detener la exploración si la suma parcial supera T.
    Optimalidad: si alcanzamos T antes de considerar todos los elementos, detenemos esa rama.

    Poda de factibilidad: la suma de lo actual mas los restantes sean menor que k

    (j) codeado


2) MagiCuadrados

    (a) Habría que generar n²! cuadrados para encontrar todos los cuadrados magicos con fuerza bruta.

    (b) Foto 2b

    (c) El primer nivel tiene n² nodos, cada nodo del primer nivel tiene n²-1 hijos, por lo que el segundo nivel tiene n²*(n²-1) nodos
    y asi...n²*(n²-1)*(n²-2)*(n²-3)*...*1, luego el arbol de backtracking queda n²! nodos el peor caso.

    (d) Se puede hacer para las columnas si se supiera el numero magico de forma precalculado.

    (e) Demostrar que el número mágico de un cuadrado mágico de orden n es siempre (n³ + n)/2.

    d/ Vamos a sumar de distinta forma todos los numeros de 1 a n².
        -1- sumar todos los numeros de 1 a n² se puede hacer con la suma de gauss: sumaTotal = (n²(n²+1))/2
        -2- como un cuadrado magico de orden n tiene n filas, entonces se puede: sumaTotal = nro magico * n
        Igualamos ambas formulas y dividimos ambos lados n, queda (n³+n)/2 

3) MaxiSubconjunto

    (a) Si tenemos orden 4, k = 3:
                        las soluciones candidatas son: (1, 1, 1, 0), (1, 1, 0, 1), (1, 0, 1, 1), (0, 1, 1, 1)
                        cada elem representa si el indice de su posicion esta o no esta
                        las solucion/es validas son el conjunto de indices que maximice evaluando a la matriz
                        las soluciones parciales son los conjuntos de indices que tienen menos que k elementos y aun hay para agregar

    (b) Complejidad temporal: cada indice puede estar o no estar O(2^k) y cuando llego a una hoja calculo la sumatoria en O(n²) un total del
        numero combinatorio(n,k). Luego en total queda: O(2^k * comb(n,k) * n²) //esto no se si esta bien

        Complejidad espacial: uso solo un vector de booleanos de tamaño k, y una matriz de tamaño n*n. Queda O(k + n²)

    (c) Poda de Optimalidad: si agregando todos los indices restantes no llego a k, detengo esa rama. Eso quiere decir que siguiendo por
        esa rama no se llega a tener un conjunto de indices de tamaño k. 
        
        (edit+) Esta poda es correcta porque se basa en una cota superior del valor que podría alcanzar una solución parcial. 
        Si esta cota no es mejor que la mejor solución encontrada hasta el momento, entonces sabemos que no necesitamos seguir 
        explorando esa rama del espacio de soluciones.

4) RutaMinima

    (a) Una solucion candidata es un vector de tamaño n que contiene indices.
        La solucion valida es la que minimiza la formula del ejercicio evaluando los indices del vector en la matriz. 
        Una solucion parcial es cuando aun tengo indices para agregar cuando el tamaño del vector solucion no llega a n.

    (b) La complejidad temporal es O(n!) en el peor caso ya que exploramos todas las permutaciones posibles de n elem.
        La complejidad espacial es O(n) ya que almaceno solo una permutacion a la vez.

    (c) Una poda por optimalidad podría ser descartar cualquier solución parcial cuyo valor ya exceda el valor de la mejor solución 
        encontrada hasta el momento. Esto es correcto porque estamos buscando minimizar el valor, así que cualquier solución parcial 
        que ya sea peor que una solución completa encontrada anteriormente no puede llevar a una solución óptima.

5) SumaDinámica

    (a) Me convence ;)

    (b) Si tenemos {1, 2, 5, 5, 5} los elementos 5+1 se suman minimo 3 veces. 

    (c) Considerado ;)

    (d) La complejidad con enfoque dinamico tiene complejidad O(n*k) mientras que con backtracking es de O(2^n).
        Si k<<2^n es mejor con dinamica, cuando k>>2^n es mejor con backtraking.

    (e) :)

    (f) No vimos bottom up aun :)

    (g) Demostrar que la función recursiva del inciso a) es correcta.
                      _
                     |  j == 0                                  si i = 0
        ss’C(i,j) = <   ss’C(i-1, j)                            si i!=0 && c[i]>j
                     |_ ss’C(i-1, j) || ss’C(i-1, j-c[i])       si no

        d/ inducción en i que existe algún subconjunto de {c1 , . . . , ci } que suma j si y solo si ss’C (i, j) = V
            
            caso base: i = 0 ss’C(i, j) = j==0 es true si y solo si j==0 cumple.
            paso inductivo: supongamos que la función ss’C es correcta para i desde 0 hasta k-1, qvq es correcta para i = k.
                -Si HI es ciertam tenemos que para cualquier j y 0<=i<=k-1, ss’C(i, j) es V si existe un subconjunto {c_1, ..., c_n}
                que sume j.
                - suponemos 2 casos para ss’C(k, j):
                    1) si c[k]>j: debe ser F ya que ningún subconjunto que la suma se igual a j, agregando el elemento k puede sumar j
                    2) si c[k]<=j: segun la definicion de la función ss’C(k,j) = ss’C(k-1, j) || ss’C(k-1, j-c[k])

                    Por HI sabemos que ss’C(k-1, j) es V sii hay un subconjunto que sume j y que ss’C(k-1, j-c[k]) es V si existe un 
                    subconjunto que sume j-c[k].

                    Si ss’C(k,j) es V uno de los dos casos de arriba es V, si tomamos ambos subconjuntos alguno suma j.
                    Si ss’C(k,j) es F entonces no hay un subconjunto que sume j.

6) OptiPago

    (a)función recursiva cc(B, c) para resolver el problema, donde cc(B, c) = (c′ , q) cuando el mínimo costo mayor o igual a c 
    que es posible pagar con los billetes de B es c′ y la cantidad de billetes mínima es q
                 _
                |   <|c|,0>           si c<0                           //devuelvo el exceso
    cc(B, c)=  <    <inf, inf>        si vacio?(B) & c>0               //cuando me quedo sin billetes
                |_  min[(1), (2)]     si no

                (1) En esta llamada recursiva uso un billete y sumo la cantidad de billetes usados. Como es una tupla de costo y cantidad 
                de billetes usados, necesito actualizar ambas partes de la tupla.

                    <(cc(B-dameUno(B), c-dameUno(B)))_0, (cc(B-dameUno(B), c-dameUno(B)))_1 +1 >
                        1° parte de la tupla (_0)               2° parte de la tupla (_1)

                (2) En esta parte de billete elijo no usar el billete en cuestion, no hace falta actualizar nada ya que la funcion como tal
                devuelve una tupla.

                    cc(B- dameUno(b), c)
                
                (*) El B-dameUno(B) es de cjto, c-dameUno(B) es resta enteros, min de tuplas (minimiza 1° elem de la tupla -> 2° elem)

    (b) La complejidad es O(2^|B|). -codeado-

    (c) cc’B (i, j) = cc({b1 , . . . , bi }, j) que implemente la idea anterior dejando fijo el parámetro B

                     _
                    |   <|e|,0>           si e < 0                       //devuelvo el exceso
    cc’B(i, e)=    <    <inf, inf>        si i < 0 & e > 0              //cuando me quedo sin billetes y tengo costo que cubrir
                    |_  min[(1), (2)]     si no

                (1) Usar el billete: <cc’B(i - 1, e - B[i])_0, 1 + cc’B(i -1, e - B[i])_1> 
                                        1° parte de la tupla     2° parte de la tupla

                (2) No usar billete: cc’B(i - 1, e)

    Explicado con palabras: la funcion cc’B(i, e) calcula el minimo exceso posible usando los billetes del multiconjunto B, minimizando
        también la cantidad de billetes, el resutado se representa como una tupla <exceso, cantBilletes>

        Parámetros: i representa el i-esimo billete de B y e representa el costo que debe cubrir.

        Casos base: explicado en comentarios

        Caso recursivo: calcula el minimo entre contar el i-esimo billete o no. 
                        (*) Si cuenta el i-esimo billete en la tupla_1 le resto a e el valor del i-esimo billete y a tupla_2 sumo uno la cantidad
                        de billetes, y a ambos le resto el indice para seguir iterando.
                        (*) Si no cuenta el i-esimo billete simplemente le resto un indice.

    cc’B tiene la propiedad de superposición de subproblemas cuando tenemos que calcular valores de billetes repetidos para un mismo estado
    de e, ya que como estamos viendo el caso de usar o no usar tal billete, con los billetes del mismo valor, voy a estar calculando
    lo mismo varias veces. En el peor caso es que sean |B| cantidad de billetes diferentes con un estado e diferente. La cantidad de 
    estados en el peor caso es |B|*e <<< 2^(|B|/2). Conviene dinamica :)

    (d) Estructura de memoización para cc’B: matriz[i][j] con i = |B| y j = costo inicial a cubrir.

    (e) -codeado-

    (f) La llamada para resolver es cc’B(|B|-1, costo) y la complejidad del nuevo algoritmo es O(|B| * costo)

7) AstroTrade

    (a) Quiero maximizar ganancia. Empezar y terminar sin asteroides.
        si Astro Void tiene c asteroides al fin del día j, es:
            indefinido (i.e., −∞) si c < 0 o c > j, o
            el máximo entre:
                la m.g.n. de finalizar el día j − 1 con c − 1 asteroides y comprar uno en el día j,
                la m.g.n. de finalizar el día j − 1 con c + 1 asteroides y vender uno en el día j,
                la m.g.n. de finalizar el día j − 1 con c asteroides y no operar el día j.

    (b) Función recursiva:
                          _
                         |                -Inf                                                      si c < 0 || c > j
            mgn(c, j) = <                   0                                                       si j == 0 y c == 0
                         |_ max(mgn(c - 1, j - 1) - P[j], mgn(c + 1, j - 1) + P[j], mgn(c, j-1))    si no

    (c) Llamada para resolver el problema con esa funcion recursiva es: mgn(c, n).

    (d) -codeado-
        Como se puede tener a lo sumo n asteroides (en realidad menos) los estados del problemas son en el peor caso
        n * n y por eso la complejidad temporal es de O(n²).
        Como uso una matriz de n² para la memorizacion, la complejidad espacial es de O(n²)

        La eleccion de la estructura se basa en que nunca puede haber mas asteroides que dias, por eso usamos la cota
        del dia para los asteroides, en realidad vendria a ser n/2 ya que si tiene n/2+1 de asteroides en cualquier momento,
        no se llegaria a vender (es imposible tener (n/2)+1 en los primeros (n/2)-1 dias)

        Otro cambio que hice en el código fue que la la llamada de recursion es de: MGN(0, 0) empezando en dia 0 con 0 asteroides.
        No me salio hacerlo como en la recursion de arriba.

8) CortesEconomicos

    (a) Queremos encontrar el mínimo costo posible de cortar una vara de longitud ℓ. Me convence :)

    (b) Función recursiva:
                          _
                         |       0       si |C| = 0
    corteMin(C, i, j) = <   
                         |_     min     (corteMin(C - C[k], i, C[k]), corteMin(C - C[k], C[k], j)) + (j-i)     si no
                   0 <= k < |C| && i <= C[k] < j

    corteMin calcula el minimo costo de cortar una vara de longitud j. Los parametros de entrada son un vector de enteros que 
    indican donde tienen que ser cortados, y dos enteros i, j que indican el limite de la vara en cuestión.
    El caso base es cuando me quedo sin indicacion de donde se tiene que cortar, es decir cuando el vector esté vacio.
    El caso recursivo consiste en explorar todas las permutaciones del vector C, calculando el minimo de quedarse con el trozo
    derecho o izquierdo luego del corte. La complejidad de esto en el peor caso es de O(2^(|C|!))

    