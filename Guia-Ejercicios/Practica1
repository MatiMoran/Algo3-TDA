Practica 1: tecnicas algoritmicas

Bactracking

1) SumaSubconjuntosBT       
    Las soluciones (candidatas) son los vectores a = (a1 , . . . , an ) de valores binarios; el subconjunto
    de C representado por a contiene a ci si y sólo si ai = 1.
    a es una solución válida cuando la suma del subconjunto es igual a k.

    (a) C = {6, 12, 6} y k = 12
    soluciones candidatas: a1 = (0, 0, 0)   a2 = (1, 0, 0)  a3 = (1, 1, 0)  a4 = (1, 0, 1)
                        a5 = (1, 1, 1)   a6 = (0, 1, 1)  a7 = (0, 0, 1)  a8 = (0, 1, 0)     

    (b) C = {6, 12, 6} y k = 12
    soluciones validas: a1 = (0, 1, 0)  a2 = (1, 0, 1)

    (c) C = {6, 12, 6} y k = 12
    soluciones parciales: p1 = ()   -> p2 = (0) -> p3 = (0, 0) -> p4 = (0, 0, 0)
                                                            -> p5 = (0, 0, 1)
                                                -> p6 = (0, 1) -> p7 = (0, 1, 0)
                                                            -> p8 = (0, 1, 1)
                                    -> p9 = (1) -> p10 = (1, 0) -> p11 = (1, 0, 0)
                                                                -> p12 = (1, 0, 1)
                                                -> p13 = (1, 1) -> p14 = (1, 1, 0)
                                                                -> p15 = (1, 1, 1)

    (d) El arbol de backtracking es similar a las soluciones parciales, se empieza con la solucion vacia y se van agregando o no
    agregando elemntos al subconjunto, los nodos intermedios son soluciones parciales, y la hojas son soluciones candidatas.
    Las soluciones candidatas que sumen 12 seran las soluciones validas.

    (e) Me convence :)

    (f) Me convence también :)

    (g) árbol de llamadas recursivas: C = {6, 12, 6} y k = 12. Llamada: ss(C, |C|, k)

    llamada recursiva: ss(C, i - 1, j) v ss(C, i - 1, j - C[i])

    ss(C, 3, 12) -> ss(C, 2, 12)                                                  
                -> ss(C, 1, 12)                   v                       ss(C, 1, 0)
                    -> ss(C, 0, 12) v ss(C, 0, 6)                             -> ss(C, 0, 0) v ss(C, 0, -6)
                        false       v     false                                   true (0,1,0) v false
                v
                -> ss(C, 2, 6)
                -> ss(C, 1, 6)                   v                       ss(C, 1, -6)
                    -> ss(C, 0, 6) v ss(C, 0, 0)                             -> ss(C, 0, -6) v ss(C, 0, -12)
                        false       v true (1,0,1)                                false      v  false



    (h) Me convence x3 :)

    (i) Factibilidad: detener la exploración si la suma parcial supera T.
    Optimalidad: si alcanzamos T antes de considerar todos los elementos, detenemos esa rama.

    Poda de factibilidad: la suma de lo actual mas los restantes sean menor que k

    (j) codeado


2) MagiCuadrados

    (a) Habría que generar n²! cuadrados para encontrar todos los cuadrados magicos con fuerza bruta.

    (b) Foto 2b

    (c) El primer nivel tiene n² nodos, cada nodo del primer nivel tiene n²-1 hijos, por lo que el segundo nivel tiene n²*(n²-1) nodos
    y asi...n²*(n²-1)*(n²-2)*(n²-3)*...*1, luego el arbol de backtracking queda n²! nodos el peor caso.

    (d) Se puede hacer para las columnas si se supiera el numero magico de forma precalculado.

    (e) Demostrar que el número mágico de un cuadrado mágico de orden n es siempre (n³ + n)/2.

    d/ Vamos a sumar de distinta forma todos los numeros de 1 a n².
        -1- sumar todos los numeros de 1 a n² se puede hacer con la suma de gauss: sumaTotal = (n²(n²+1))/2
        -2- como un cuadrado magico de orden n tiene n filas, entonces se puede: sumaTotal = nro magico * n
        Igualamos ambas formulas y dividimos ambos lados n, queda (n³+n)/2 

3) MaxiSubconjunto

    (a) Si tenemos orden 4, k = 3:
                        las soluciones candidatas son: (1, 1, 1, 0), (1, 1, 0, 1), (1, 0, 1, 1), (0, 1, 1, 1)
                        cada elem representa si el indice de su posicion esta o no esta
                        las solucion/es validas son el conjunto de indices que maximice evaluando a la matriz
                        las soluciones parciales son los conjuntos de indices que tienen menos que k elementos y aun hay para agregar

    (b) Complejidad temporal: cada indice puede estar o no estar O(2^k) y cuando llego a una hoja calculo la sumatoria en O(n²) un total del
        numero combinatorio(n,k). Luego en total queda: O(2^k * comb(n,k) * n²) //esto no se si esta bien

        Complejidad espacial: uso solo un vector de booleanos de tamaño k, y una matriz de tamaño n*n. Queda O(k + n²)

    (c) Poda de Optimalidad: si agregando todos los indices restantes no llego a k, detengo esa rama. Eso quiere decir que siguiendo por
        esa rama no se llega a tener un conjunto de indices de tamaño k. 
        
        (edit+) Esta poda es correcta porque se basa en una cota superior del valor que podría alcanzar una solución parcial. 
        Si esta cota no es mejor que la mejor solución encontrada hasta el momento, entonces sabemos que no necesitamos seguir 
        explorando esa rama del espacio de soluciones.

4) RutaMinima

    (a) Una solucion candidata es un vector de tamaño n que contiene indices.
        La solucion valida es la que minimiza la formula del ejercicio evaluando los indices del vector en la matriz. 
        Una solucion parcial es cuando aun tengo indices para agregar cuando el tamaño del vector solucion no llega a n.

    (b) La complejidad temporal es O(n!) en el peor caso ya que exploramos todas las permutaciones posibles de n elem.
        La complejidad espacial es O(n) ya que almaceno solo una permutacion a la vez.

    (c) Una poda por optimalidad podría ser descartar cualquier solución parcial cuyo valor ya exceda el valor de la mejor solución 
        encontrada hasta el momento. Esto es correcto porque estamos buscando minimizar el valor, así que cualquier solución parcial 
        que ya sea peor que una solución completa encontrada anteriormente no puede llevar a una solución óptima.
