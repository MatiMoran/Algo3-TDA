Práctica 4: Recorridos y Árboles

1) Bipartición y ciclos
    Sea T un árbol generador de un grafo (conexo) G con raíz r, y sean V y W los vértices que están a distancia par e impar de r, respectivamente.
    (a) Observar que si existe una arista vw ∈ E(G) \ E(T) tal que v, w ∈ V o v, w ∈ W , entonces el único ciclo de T ∪ {vw} tiene longitud impar.
        Si v, w están en V donde todos los vértices están a distancia par, entonces el ciclo de incluir vw consiste partiendo desde r hacia
        v (par) y r hacia w (par), más la arista vw que no está en T, formando así un ciclo de longitud impar.
        Análogamente si v, w estan en W donde todos los vertices están a distancia impar. Entonces impar + impar + 1 es impar.

    (b) Observar también que si toda arista de E(G) \ E(T) une un vértice de V con otro de W, entonces (V, W) es una bipartición de G y, por lo 
    tanto, G es bipartito. 
        En un grafo bipartito no hay aristas que conecten vértices dentro del mismo conjunto. En este caso V y W. 
        Como T  es un árbol generador de G, sabemos que T conecta todos los vértices de G sin formar ciclos. Cumple con la definición de bipartito.
        Al agregar más aristas que no están en T  pero que siguen conectando con vértices de V con W, simplemente se está reforzando la bipartición
        sin introducir nuevos ciclos pares ni conexión dentro del mismo conjunto.
        Esto nos indica que el grafo es bipartito.
    
    (c) A partir de las observaciones anteriores, diseñar un algoritmo lineal para determinar si un grafo conexo G es bipartito. 
    En caso afirmativo, el algoritmo debe retornar una bipartición de G. 
    En caso negativo, el algoritmo debe retornar un ciclo impar de G.
    Explicitar cómo es la implementación del algoritmo; no es necesario incluir el código.
        1. Inicialización: inicializar conjuntos V y W que representarán los vértices a distancia par e impar de la raíz r. 
            Un vector de visitados para marcar los vértices que ya se han explorado durante el DFS indicando el nivel en lugar de un booleano.
        2. DFS modificado: cada vez que visites un vértice, decide si debe ir al conjunto V o al conjunto W basándose en su profundidad (nivel) 
            en el árbol DFS. Si la profundidad es par, el vértice va al conjunto V; si es impar, va al conjunto W.
        3. Verificación de ciclo impar: la clave para verificar si el grafo es bipartito está en observar las aristas E(G) \ E(T), 
            es decir, las aristas que no son parte del árbol DFS generado. Cada vez que encuentres una arista que conecte dos vértices en el 
            mismo conjunto V o W, habrá encontrado un ciclo impar. Si encuentra tal arista, el algoritmo debería terminar y retornar este ciclo 
            impar reconstruyendolo con el vector padre generado por el DFS para ambos vértices.
        4. Construcción de la Bipartición o Ciclo Impar: Si después de explorar todo el grafo no encuentra ninguna arista que conecte dos vértices 
            dentro del mismo conjunto, entonces confirmamos que el grafo es bipartito, y los conjuntos V y W representan una bipartición válida del 
            grafo. En este caso, el algoritmo debe retornar esta bipartición.
    
    (d) Generalizar el algoritmo del inciso anterior a grafos no necesariamente conexos observando que un grafo G es bipartito si y solo si sus 
    componentes conexas son bipartitas.
        Generalización a Grafos No Conexos: Para extender el algoritmo a grafos no necesariamente conexos, simplemente ejecuta el DFS modificado 
        desde cada vértice no visitado del grafo. Esto asegura que explorarás cada componente conexa. Si encuentras un ciclo impar en cualquier 
        componente, el grafo no es bipartito. De lo contrario, el grafo es bipartito, y hay una bipartición válida para cada componente.

2)PuentesDFS
    Una arista de un grafo G es puente si su remoción aumenta la cantidad de componentes conexas de G. Sea T un árbol DFS de un grafo conexo G.
    (a) Demostrar que vw es un puente de G si y solo si vw no pertenece a ningún ciclo de G.
        ->) vw es un puente de G entonces vw no pertenece a ningún ciclo de G
        Mostramos por el absurdo, supongamos que vw es un puente y pertenece a un ciclo, ahora sacamos vw, por definición de puente se tiene que
        generar más componentes conexas, en particular v y w tienen que pertenecer a distintas componentes conexas. Pero como la arista vw pertenecía
        a un ciclo, aún existe camino desde v a w, ya que la existencia de un ciclo garantiza que la eliminación de una arista no puede aumentar el
        número de componentes conexas, porque siempre habrá al menos un camino alternativo que mantiene unidos a todos los vértices del ciclo.
        Por lo tanto vw no era puente. ABS! 
        <-) vw no pertenece a ningún ciclo de G entonces vw es puente
        Si vw no pertenece a ningún ciclo, significa que es la única vía de conexión directa entre v y w. Por lo tanto, su remoción inevitablemente 
        separa el grafo en al menos dos componentes conexas, ya que no hay ruta alternativa que mantenga unidos a v y w, cumpliendo con la definición 
        de puente. La inexistencia de un ciclo implica directamente que la arista es crítica para la conectividad entre v y w, y su remoción 
        efectivamente particiona el grafo.
        
    (b) Demostrar que si vw ∈ E(G) \ E(T), entonces v es un ancestro de w en T o viceversa.
        Sé que vw pertenece a G pero no a T que es un árbol DFS, por propiedad de la construcción del árbol DFS sabemos que es una backedge, de lo 
        contrario estaría en T. Luego v es ancestro de w o viceversa.
        En un árbol DFS, una backedge siempre conecta un vértice con otro vértice que es su ancestro dentro del árbol, porque el recorrido en 
        profundidad garantiza que antes de explorar un nuevo vértice, se explora completamente cada uno de los vértices descubiertos (incluyendo todos 
        sus descendientes en el árbol). Por lo tanto, cuando encuentras una backedge, esta necesariamente conecta un vértice con otro que ya había 
        sido explorado, y dado el recorrido en profundidad, el vértice previamente explorado tiene que ser un ancestro del más recientemente descubierto.
    
    (c) Sea vw ∈ E(G) una arista tal que el nivel de v en T es menor o igual al nivel de w en T. 
    Demostrar que vw es puente si y solo si v es el padre de w en T y ninguna arista de G \ {vw} une a un descendiente de w (o a w) 
    con un ancestro de v (o con v).
        - Esto es basicamente la definición de covertura: Decimos que una backward edge b cubre a una tree edge (u, v) de un árbol DFS T con u padre
        de v si b conecta un descendiente de u con un ancestro de v en T.
        - Entonces traduciendo el ejercicio con la definición de covertura queda:
            Una tree edge de un árbol DFS T de un grafo conexo G es un puente si y sólo si no hay ninguna backward edge que la cubra.
        (La demo está en el pdf de puentes Lema 3).

    (d) Dar un algoritmo lineal basado en DFS para encontrar todas las aristas puente de G.
        (En el pdf de puentes)

5)GeoBFS
    Un árbol generador T de un grafo G es v-geodésico si la distancia entre v y w en T es igual a la distancia entre v y w en G para todo w ∈ V(G). 
    Demostrar que todo árbol BFS de G enraizado en v es v-geodésico. 
    Dar un contraejemplo para la vuelta, i.e., mostrar un árbol generador v-geodésico de un grafo G que no pueda ser obtenido cuando BFS se 
    ejecuta en G desde v.

    Veamos como funciona BFS: inicia desde un vértice v y explora todos sus vecinos a distancia 1, luego todos los vecinos de estos a distancia 2,
    y así sucesivamente. Esto significa que cuando un vértice w es visitado y agregado al árbol BFS, la ruta desde v hasta w es la más corta 
    posible en G, ya que de haber una más corta, w habría sido visitado antes.

    Su relación con v-geodésico: dado que BFS explora gradualmente los vértices de G en orden de distancia creciente desde v, cuando un vértice w 
    se agrega a T, la ruta de v a w en T es igual a la distancia más corta de v a w en G. Por lo tanto, el árbol BFS enraizado en v es 
    v-geodésico, ya que conserva la distancia mínima entre v y todos los demás vértices en G.

    Contraejemplo para la vuelta: la propiedad de ser v-geodésico no es exclusiva de los árboles BFS; otros métodos podrían generar un árbol 
    generador v-geodésico que no siga el orden específico de un BFS. Considera un grafo G que es un cuadrado con vértices A, B, C, D y 
    aristas AB, BC, CD, y AD, y una diagonal AC. Si eliges A como el vértice raíz para un BFS, el árbol resultante podría ser A-B-C-D 
    (asumiendo que el orden de visita es de izquierda a derecha), que es A-geodésico. Sin embargo, otro árbol generador A-geodésico podría ser 
    simplemente tomar las aristas AB, AC y AD, el cual no es obtenible por un BFS desde A, ya que BFS siempre producirá un árbol sin la arista AC
    debido a su naturaleza de exploración en anchura.

8)GrillaMágica
    Se tiene una grilla con m × n posiciones, cada una de las cuales tiene un número entero en [0, k), para un k ∈ N dado. 
    Dado un valor objetivo w ∈ N y una posición inicial (x1 , y1 ), que tiene un valor inicial v1 , queremos determinar la mínima cantidad 
    de movimientos horizontales y verticales que transformen v1 en w, teniendo en cuenta que el i-ésimo movimiento transforma 
    a vi por vi+1 = (vi + z) mód k, donde z es el valor que se encuentra en la casilla de destino del movimiento. 

    Modelar este problema como un problema de grafos que se resuelva usando BFS en O(kmn) tiempo.

    Consideramos cada posición de la grilla como un nodo y para cada nodo consideramos movimiento posible horizontal y vertical. Si el movimiento
    es válido, siendo z el valor del destino establecemos arista.
    Corremos BFS: -Nodo inicial (x1, y1) con valor v1, cola visitados
                  -Mientras cola no vacía: extraer nodo de cola, ver si valor es w, si es, encontramos y terminamos. Si no, encolamos los vecinos
                                            no visitados y actualizamos valor con la fórmula.
                  -Si terminamos BFS sin encontrar w, no es posible obtenerlo partiendo de v1
    Obtención de cantidad mínima de movimientos: al obtener w podemos rastrear el nodo objetivo hacia el nodo inicial con un vector de padres. 

    La complejidad es O(kmn) ya que en el peor de los caos la ejecución recorre nm nodos y obtención de cant de movimientos también es O(nm).

10)SecuenciasConectadas
    Se define la distancia entre dos secuencias de naturales X = x1 , . . . , xk e Y = y1 , . . . , yk como
    d(X, Y) = SUM desde 1 a k de |xi − yi|. Dado un conjunto de secuencias X1 , . . . , Xn , cada una de tamaño k,
    su grafo asociado G tiene un vértice vi por cada 1 ≤ i ≤ n y una arista vi vj de peso d(Xi , Xj )
    para cada 1 ≤ i < j ≤ n. Proponer un algoritmo de complejidad O(kn2 ) que dado un conjunto
    de secuencias encuentre el árbol generador mínimo de su grafo asociado.

    